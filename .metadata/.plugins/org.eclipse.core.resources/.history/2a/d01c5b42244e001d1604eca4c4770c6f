package musique.javax;
import java.io.File;
import java.io.IOException;

import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.UnsupportedAudioFileException;

import mesmaths.bsplines.OutilsNaiveBSpline;
import musique.SonBref;
import mesmaths.bsplines.FoncteurNaiveNo4;
/*
 * 
 * teste la possibilité de diffuser plusieurs sons simultanément, voire beaucoup de sons simultanément : 
 * comme les applaudissements de spectateurs, une chorale, etc.
 * Pour tester une cacophonie, un brouhaha
 * 
 * ici les sons sont individuellement modulables en volume et en "balance"
 * 
 * */
public class TestBrouhahaSonBrefHuey
{



public static void main(String[] args)
{
try
    {
    File répertoire = new File("");
    répertoire = new File(répertoire.getAbsoluteFile(),"musique"+File.separatorChar+"bruits");
    String nomFichier = "huey2.wav";
    
    int effectif = 15;                          // pour huey
    SonBref sons[] = new SonBref[effectif];
    
    int débutExtrait, finExtrait;           /* en centièmes de secondes */
    int pasTemporel = 20;                   /* en centièmes de secondes*/ 
    int i;
    int débutAbsolu = 3000;                 /* en centièmes de secondes*/ 
    for ( i = 0, débutExtrait = débutAbsolu, finExtrait = débutAbsolu + pasTemporel; i < effectif; ++i, finExtrait += pasTemporel)
        { 
        sons[i] = new SonBrefJavax(répertoire,nomFichier,débutExtrait,finExtrait);
        débutExtrait = finExtrait;
        }
    
    /* on a découpé l'intervalle temporel [3000,3300] en 15 intervalles de taille identique */
    /* on va diffuser le son en bouclant sur le tableau. 
     * Plusieurs sons vont être joués en parallèle, le volume et la balance varient d'un passage au suivant */
    
    System.out.println("les sons sont prêts");
    
    double milieu = 0.5*effectif;
    double rayon = milieu;
    FoncteurNaiveNo4 foncteurNaiveNo4 = new FoncteurNaiveNo4(milieu, rayon);
    /* foncteurNaiveo4 est une fct "cloche", un peu comme une gaussienne, qui donne toujours des valeurs sur [0,1],
     * cette cloche est centrée au milieu de l'extrait et son rayon est la moité de la durée totale de l'extrait,
     * cela sert à faire varier de façon lisse et périodique le volume, la balance et la fréquence des diffusions */
    /* le son produit doit rester harmonieux, sans coupure et sans craquements ou cliquetis */
    
    
    int nombreRépétitions = 180; /* arbitraire, on met ce qu'on veut. ici on va boucler 12 fois sur le tableau,
                                     on obtient donc 12 périodes consécutives 
                                     Rappel mathématique : 12 périodes signifie que la diffusion va se répéter de façon strictement identique 12 fois */
    
    for ( i = 0; i < nombreRépétitions; ++i) // on boucle sur le tableau
        {
        int j = i%effectif;                                 // ainsi on accède toujours à un élément du tableau 
        double y = foncteurNaiveNo4.calcule(j);             /* calcule l'intensité y entre 0 et 1 en fct de i, l'intensité est maximale et vaut 1 lorsque i 
                                                             correspond au milieu de l'extrait, l'intensité y s'approche de 0 lorsque i est proche du début 
                                                             du tableau ou proche de la fin du tableau  */
        int délai = (int)(200*(1-y));                       /* délai entre 2 diffusions consécutives. en millisecondes. varie entre 0.2 s et 0 s */
        
        Thread.sleep(délai);                                // main "attend" et est donc bloquée pour une durée de délai millisecondes
        double volume = 0.6*y+0.4;                          // le volume varie périodiquement. toujours sur l'intervalle [0,1]
        double balance = -1+2*y;                            // la balance varie périodiquement. toujours sur l'intervalle [-1,1]
        sons[j].joue(volume,balance);                       // on diffuse le son sur les hauts-parleurs
        
        //System.out.println("i = " + i);
        //System.out.println("y = " + y);
        }
    System.out.println("1. les sons ont été joués");
    int c = System.in.read();
    
    /*après avoir écouté cette diffusion, réécouter le fichier son initial et comparer pour noter les effets sonores obtenus */
    
    /* la diffusion du son est mauvaise sur la boucle qui suit car le même objet son (et donc la même ligne) est utilisé simultanément par plusieurs threads
     * exemple de ce qu'il ne faut pas faire  !!! */
    
    for (i = 0; i < 100; ++i) 
        {
        int durée = (int)(200*Math.random());  //durée définie aléatoirement entre 0 et 200 millisecondes. en millisecondes 
        Thread.sleep(durée);
        
        sons[0].joue(1,0);
        }
    System.out.println("2. les sons ont été joués");
    
    c = System.in.read();
     
    }
catch (SecurityException e)
    {
    // TODO Auto-generated catch block
    e.printStackTrace();
    }
catch (IllegalArgumentException e)
    {
    // TODO Auto-generated catch block
    e.printStackTrace();
    }
catch (UnsupportedAudioFileException e)
    {
    // TODO Auto-generated catch block
    e.printStackTrace();
    }
catch (IOException e)
    {
    // TODO Auto-generated catch block
    e.printStackTrace();
    }
catch (LineUnavailableException e)
    {
    // TODO Auto-generated catch block
    e.printStackTrace();
    }
catch (InterruptedException e)
    {
    // TODO Auto-generated catch block
    e.printStackTrace();
    }


}

}
